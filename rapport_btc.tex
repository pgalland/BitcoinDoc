\documentclass[11pt,a4paper]{article}
\usepackage[top=80px, left=70px, right=70px]{geometry}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage[francais]{babel}
\usepackage{graphicx}
\usepackage{float}

\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{amssymb}
\usepackage{url}

\usepackage[table]{xcolor}


\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}

\title{Comprendre Bitcoin\\
Rapport de projet INFRES357
}

\author{Pierre Galland, Benoît de Laitre}

\begin{document}
\maketitle

\tableofcontents
 \nocite{*}
 
\newpage

\section{Le protocole Bitcoin}

\subsection{Briques de base}

Le protocole de Bitcoin utilise plusieurs briques de bases de la cryptographie : le chiffrement asymétrique, la signature et le hachage. C'est d'ailleurs là que réside l'intérêt de ce protocole, c'est un assemblage astucieux de briques qui existent depuis de nombreuses années et qui sont très bien connues, pourtant cet assemblage crée une technologie totalement nouvelle.

\subsubsection{Chiffrement asymétrique}

Le principe du chiffrement asymétrique est que les clefs vont par paire, une clef publique et une clef privé $(K_{Pub}, K_{Pri})$. On peut voir les clefs comme des suites finies de caractères ou de chiffres, et les message aussi. Il est possible de chiffrer un message avec la clef privé et alors le message chiffré ne pourra être déchiffré qu'avec la clef publique correspondante. De même on peut chiffrer un message avec la clef publique et alors il ne pourra être déchiffré qu'avec la clef privé correspondante. Considérons l'exemple classique de Bob et Alice, ils possède chacun une paire clef publique/clef privée. La paire de clefs de Bob est 
$(K_{Pub}^{B}, K_{Pri}^{B})$ et celle d'Alice est $(K_{Pub}^{A}, K_{Pri}^{A})$.\\\\

Si Bob veut envoyer un message $mess$ à Alice qu'elle seule pourra lire, alors il chiffre son message avec le clef publique d'Alice, et il obtient le message chiffré $*mess*$ :

$$chiffrer(mess, ~K_{Pub}^{A}) \rightarrow *mess*$$

Il envoie alors ce message $*mess*$ à Alice, qui quand elle le reçoit le déchiffre avec sa clef privée $K_{Pri}^{A}$ :

$$déchiffrer(*mess*, ~K_{Pri}^{A}) \rightarrow mess$$

Si Alice essayait de déchiffrer le message $*mess*$ avec une autre clef que sa clef privée $K_{Pri}^{A}$ alors cela ne marcherait pas, elle obtiendrait n'importe quoi (une suite de symbole qui n'a rien à voir avec le message $mess$). Donc comme on considère qu'Alice est la seule à connaître sa clef privée, elle est la seule à pouvoir déchiffrer le message.

$$déchiffrer(*mess*, ~K_{Pri}^{autre}) \rightarrow n'importe~quoi$$

On peut également utiliser la paire clef publique/clef privée dans l'autre sens. Si Bob chiffre un message avec sa clef privée $K_{Pri}^{B}$ alors on ne pourra le déchiffrer qu'avec sa clef publique $K_{Pub}^{B}$. En essayant de le déchiffrer avec une autre clef $K_{Pub}^{autre}$ on obtiendrait n'importe quoi.\\\\ Ainsi si Alice veut que Bob prouve qu'il est bien Bob donc qu'il connaît la clef privée $K_{Pri}^{B}$, sans qu'il ait à révéler cette clef, alors elle peut créer un message $mess2$ et demander à Bob de le chiffrer avec sa clef $K_{Pri}^{B}$ et de lui envoyer le résultat $*mess2*$. Alice va ensuite déchiffrer $*mess2*$ avec la clef publique de Bob $K_{Pub}^{B}$ et si elle retombe bien sur $mess2$ cela prouve que Bob est bien Bob (qu'il connaît la clef $K_{Pri}^{B}$). Ce mécanisme sera très utile pour la signature, décrite plus loin.
\subsubsection{Hachage cryptographique}

On considère toujours nos messages comme des suites finies de caractères ou de chiffres (d'ailleurs in fine sur un ordinateur toute donnée est une suite finie de chiffres). Le but d'une fonction de hachage cryptographique $h$ est de transformer chaque message de taille inférieure à $T$ (où $T$ est très très grand) en un message de taille beaucoup plus petite que $T$ (par exemple dans Bitcoin en message de longueur 256 chiffres). Si j'ai un message $mess$ assez long alors $h(mess)$ sera beaucoup plus petit que $mess$. On appellera $h(mess)$ le hash de $mess$. \\\\
Prenons un exemple avec la fonction de hachage SHA-256, qui est utilisée dans Bitcoin. Je considère le message $mess$ suivant et je calcule son $h(mess)$ : 
$$mess = Un~message~pas~très ~long, ~juste ~pour ~faire ~un ~exemple $$
$$h(mess) \rightarrow 6423e8584411fee28e5064799d8a230c64f999c448c769ab7d309baba9a33f42$$
Le but de la fonction de hachage est également que le hash d'un message puisse l'identifier de manière presque unique. Ainsi à priori si je considère deux messages différents alors leurs hashs sont également différents.  
$$mess1~ \neq ~mess2~ \Rightarrow ~presque~ toujours~ h(mess1)~ \neq ~h(mess2)$$
Un autre point important est que si je connais seulement le hash du message $h(mess)$ ainsi que la fonction de hachage $h$ mais que je ne connais pas le message $mess$ alors je ne puisse pas retrouver quel est le message $mess$. Il est impossible (cela demande trop de puissance de calcul) de retrouver le message à partir de son hash.
$$ h~ et ~h(mess) \nrightarrow mess$$
Enfin si je considère un message $mess1$ et ma fonction de hachage $h$, il m'est impossible (une fois encore cela demande trop de puissance de calcul) de trouver un message $mess2$ tel que $h(mess1) ~=~ h(mess2)$.\\\\
Les fonctions de hachage jouent un rôle très important dans le protocol Bitcoin !

\subsubsection{Signature}

Le but de la signature électronique est de s'assurer que le message que l'on reçoit a bien été envoyé par la personne qui signe, et que le message n'a pas été modifié entre le moment de la signature et sa réception. Reprenons l'exemple de Bob et Alice, avec leurs paires de clefs respectives $(K_{Pub}^{B}, K_{Pri}^{B})$ et $(K_{Pub}^{A}, K_{Pri}^{A})$. Pour qu'Alice puisse être certaine que le message qu'elle reçoit de Bob est bien de lui et qu'il n'a pas été modifié en cours de route il faut que Bob signe son message :\\

Après avoir écrit son message $mess$, Bob calcul son hash $h(mess)$

$$ mess ~ \rightarrow ~ h(mess) $$

Puis il utilise chiffre ce hash avec sa clef privée :

$$ chiffrer(h(mess),~ K_{Pri}^{B}) \rightarrow ~ *h(mess)* $$

Ce $*h(mess)*$ constitue la signature du message. Bob envoie à Alice le message avec sa signature : $ (mess, ~*h(mess)*)$. Lorsque Alice reçoit le message et la signature elle vérifie que la signature est valide et qu'elle provient bien de Bob.\\\\

Alice reçoit donc $(mess1,  ~*h(mess)*)$, on écrit $mess1$ car pour le moment on ne sait pas s'il s'agit bien du message original de Bob (il a peut-être été modifié par quelqu'un l'ayant intercepté). Alice calcule le hash de $mess1$ :

$$ mess1 ~ \rightarrow ~ h(mess1) $$

Puis elle déchiffre $*h(mess)*$ avec la clef publique de Bob. En le déchiffrant avec la clef publique de Bob $K_{Pub}^{B} $ elle s'assure que $*h(mess)*$ a bien été chiffré avec la clef privé de Bob $K_{Pri}^{B} $. En effet s'il avait été chiffré avec une autre clef privée alors en le déchiffrant avec $K_{Pub}^{B}$ on obtiendrait n'importe quoi. Comme à priori on n'est pas encore sûr que le $*h(mess)*$ que l'on déchiffre a bien été chiffré avec la clef privée de Bob, on note $?h(mess)?$ ce que l'on obtient :

$$ déchiffrer(*h(mess)*,~ K_{Pub}^{B})~ \rightarrow ~?h(mess)? $$

Enfin on compare $h(mess1)$ et $?h(mess)?$, s'ils sont égaux alors on est sûr (modulo la solidité de la fonction de hachage et de l'algorithme de chiffrement) que le message est bien de Bob et qu'il n'a pas été modifié, s'ils sont différents alors on ne peut pas faire confiance à ce message.\\\\
On peut se convaincre que c'est la cas en reprenant le processus et en imaginant qu'un attaquant modifie le message et/ou la signature en cours de route, ou qu'il essaie d'envoyer le message avec sa paire de clefs. On verra qu'à la fin le test que fait Alice donne bien $h(mess1) ~\neq~ ?h(mess)?$ (en gardant à l'esprit qu'Alice connaît la clef publique de Bob).\\
En revanche si un attaquant connaît la clef privée de Bob alors il peut très bien se faire passer pour lui !



\subsection{Une transaction Bitcoin}

\subsubsection{Identité et adresses}

Dans le protocole Bitcoin la notion d'identité repose sur le chiffrement asymétrique donc un individu est une paire clef publique/clef privée. Sachant que l'on peut générer la clef publique à partir de la clef privée, un individu est une clef privée. On parle ici d'individus dans le protocole, car une personne réelle peut très bien avoir plusieurs clefs privées et donc correspondre à plusieurs individus dans le protocole. C'est d'ailleurs normalement le cas. Chaque personne réelle possédant des bitcoins a au moins une centaine de clefs privées, donc correspond à de nombreux individus théoriques dans le protocole.\\
Les individus sont identifiés dans le protocole par leur adresse. Une adresse est un hash de clef publique. Par exemple 3J98t1WpEZ73CNmQviecrnyiWrnqRhWNLy est une adresse. Pour vérifier qu'une adresse $addr$ correspond bien à la clef publique $K_{Pub}$ on a juste à vérifier que $h(K_{Pub})~ ==~ addr$ où $h$ est la fonction de hachage définie par le protocole.

\subsubsection{Structure d'une transaction}

Tout d'abord on va considérer qu'il existe un "livre de compte" partagé entre tous les utilisateurs de Bitcoin et que chaque transaction valide est inscrite dans ce livre de compte de manière chronologique. On verra par la suite quel procédé permet l'existence de ce livre de compte, qu'on appelle la Blockchain.\\\\
Chacun peut donc accéder à l'historique de toutes les transactions valides qui ont été effectuées depuis la création de Bitcoin. Il est important de comprendre qu'il n'existe pas de pièce ou de billet de bitcoin, même virtuels. Il n'y a pas de fichiers qui représentent des bitcoins. C'est seulement la Blockchain (le livre de compte partagé) qui indique le nombre de bitcoins associé à chaque adresse.  Même cette vision n'est pas tout à fait exacte. La Blockchain n'est que l'historique de toutes les transactions valides effectuées. Il est donc plus correct de dire qu'on peut calculer le nombre de bitcoin de chaque adresse à partir de la Blockchain.\\\\
Prenons un exemple : on suppose que Bob veut envoyer 1 btc à Alice (on utilisera l'abréviation btc pour désigner l'unité de monnaie bitcoin). Bob et Alice ont toujours chacun une clef privée, respectivement $K_{Pri}^{B}$ et $K_{Pri}^{A}$, et ils ont également une adresse bitcoin : $addr_B = h(K_{Pub}^{B})$ et $addr_A = h(K_{Pub}^{A})$.\\\\
Pour que Bob puisse envoyer 1 btc, il faut qu'il dispose d'au moins 1 btc. Cela signifie qu'il faut qu'il existe dans la Blockchain une transaction qui envoie au moins 1 btc à l'adresse $addr_B$. Supposons que ce soit le cas, il y a dans la Blockchain une transaction $Tx_1$ qui envoie 1 btc à l'adresse  $addr_B$. Bob va donc retransférer vers Alice l'argent qu'il a reçu de $Tx_1$.
La transaction $Tx$ de Bob contient donc les éléments suivants :\\


\begin{figure}[H]
\begin{itemize}
\renewcommand{\labelitemi}{$\bullet$}
\renewcommand{\labelitemii}{$\star$}

\item Input
\begin{itemize}
\item $h(Tx_1)$
\item $K_{Pub}^{B}$
\item[$\bullet$] $signature(K_{Pri}^{B}, Tx^*)$
\end{itemize}

\item Output
\begin{itemize}
\item value : 1 btc
\item $addr_A$
\end{itemize}

\end{itemize}

\caption{Transaction $Tx'$}
\end{figure}

\noindent La transaction contient donc 5 champs :\\\\
Dans la partie Input la transaction indique quelle transaction précédente est utilisée pour récupérer les bitcoins. Ici c'est la transaction $Tx_1$, c'est pour cela que le premier champ est $h(Tx_1)$. Le deuxième champ est la clef publique de Bob. En effet Bob veut utiliser les bitcoins donnés à $addr_B$ par $Tx_1$, il doit donc prouver qu'il possède bien l'adresse $addr_B$. Pour cela il fournit 
$K_{Pub}^{B}$ et $signature(K_{Pri}^{B}, Tx^*)$. On peut donc vérifier d'une part que $h(K_{Pub}^{B}) == addr_B$, donc que l'adresse $addr_B$ correspond bien à la clef $K_{Pub}^{B}$, et d'autre part que $signature(K_{Pri}^{B}, Tx^*)$ est valide, donc que celui qui émet le message possède bien la clef privée $K_{Pri}^{B}$. Ce qui est signé est $Tx^*$ c'est à dire la transaction $Tx$ sans la signature (les éléments précédés d'une étoile sur la figure).\\\\
Dans la partie Output Bob indique qu'il souhaite donner 1 btc (champ value) à l'adresse $addr_A$, soit à Alice.

\subsubsection{Sécurité de la transaction}

Une fois que Bob a écrit sa transaction, il la diffuse sur le réseau Bitcoin afin qu'elle soit intégrée dans la Blockchain et devienne ainsi une transaction valide, faisant partie de l'historique des transactions Bitcoin. Nous verrons par la suite que le réseau Bitcoin est un réseau peer-to-peer, donc lorsque Bob diffuse sa transaction, n'importe qui peut y avoir accès. La transaction est diffusée en clair sur le réseau.\\\\
Cependant pour pouvoir être intégrée dans la Blockchain une transaction doit être valide. Tous les champs seront vérifiés, il sera également vérifié que l'output de la transaction précédente ($Tx_1$ dans notre exemple) est bien dirigé vers l'adresse émettrice de la nouvelle transaction 
($addr_B=h(K_{Pub}^{B})$ dans notre exemple), et qu'il est suffisant (supérieur à 1 btc dans notre exemple).
\\\\
Il est donc primordial que si un attaquant entre en possession de la transaction il ne puisse pas la modifier afin par exemple de s'attribuer les fonds plutôt qu'à Alice, ou de changer le montant de la transaction, etc. Explorons quelques tentatives d'attaques et les raisons pour lesquelles elles échouent :

\paragraph{Changer le destinataire d'une transaction\\\\}

Imaginons le scénario suivant : Bob a créé sa transaction, il la diffuse sur le réseau, en particulier Eve obtient une copie de la transaction. Eve veut essayer de modifier la transaction pour s'attribuer le 1 btc que Bob envoie à Alice, puis rediffuser cette nouvelle transaction modifiée sur le réseau, en espérant qu'elle soit intégrée dans la Blockchain. Eve possède l'adresse $addr_E$ et la clef privée 
$K^E_{Pri}$.\\\\
Eve fait un premier essai, elle crée la transaction $Tx'$ en remplaçant l'adresse $addr_A$ par son adresse $addr_E$ dans l'output :

\begin{figure}[H]
\begin{itemize}
\renewcommand{\labelitemi}{$\bullet$}
\renewcommand{\labelitemii}{$\star$}

\item Input
\begin{itemize}
\item $h(Tx_1)$
\item $K_{Pub}^{B}$
\item[$\bullet$] $signature(K_{Pri}^{B}, Tx^*)$
\end{itemize}

\item Output
\begin{itemize}
\item value : 1 btc
\item $addr_E$
\end{itemize}

\end{itemize}

\caption{Transaction $Tx'$}
\end{figure}

Mais comme la signature $signature(K_{Pri}^{B}, Tx^*)$ est faite sur $Tx^*$ et que Eve a changé un champs faisant partie de $Tx^*$, la signature n'est plus valide. Par conséquent cette transaction ne pourra jamais être acceptée dans la Blockchain. Dans un deuxième essai, Eve décide donc de changer la signature. Cependant comme elle ne connaît pas la clef privée de Bob, elle ne peut pas signer avec. Elle décide donc de signer avec sa clef privée $K^E_{Pri}$, mais à ce moment là elle doit aussi changer le deuxième champs qui contient $K^B_{Pub}$ sinon la signature sera reconnue comme invalide. Elle va donc remplacer $K^B_{Pub}$ par sa clef publique. Elle crée ainsi une transaction $Tx''$

\begin{figure}[H]
\begin{itemize}
\renewcommand{\labelitemi}{$\bullet$}
\renewcommand{\labelitemii}{$\star$}

\item Input
\begin{itemize}
\item $h(Tx_1)$
\item $K_{Pub}^{E}$
\item[$\bullet$] $signature(K_{Pri}^{E}, Tx''^*)$
\end{itemize}

\item Output
\begin{itemize}
\item value : 1 btc
\item $addr_E$
\end{itemize}

\end{itemize}

\caption{Transaction $Tx''$}
\end{figure}

Cette fois-ci la signature dans $Tx''$ est valide, car Eve a signé sur 
$Tx''^*$. Cependant il subsiste un problème et la transaction ne sera pas acceptée par la Blockchain. En effet cette transaction veut utiliser les fonds fournis à l'adresse $addr_B$ par la transaction $Tx_1$, or il va être vérifié que c'est bien la clef publique derrière $addr_B$ qui utilise ces fonds. On vérifiera donc que $h(K_{Pub}^{E}) ~==~ addr_B$ ce qui n'est pas le cas. Si Eve laissait la clef $K_{Pub}^{B}$ dans le deuxième champs alors c'est la signature qui serait invalide cette fois, puisqu'elle n'est pas faite avec la clef privée correspondant à $K_{Pub}^{B}$. Eve est donc bloquée, elle ne peut pas détourner la transaction de Bob !

\paragraph{Changer le montant d'une transaction\\\\}

Cette fois-ci Eve veut essayer de changer le montant de la transaction, le remplacer par 0.5 btc par exemple. Mais cette attaque échouera également car le champs value fait parti de $Tx^*$ et est donc signé avec $K_{Pub}^B$, on ne peut pas le changer sans rendre la signature invalide. Or on a vu dans l'exemple précédent que l'on ne peut pas changer la signature. Cette attaque échoue donc également.

\subsection{Blockchain et mineurs}

\section{Le minage}
\subsection{La parade au double-spend}

\section{Les différents types de clients}
\subsection{Découpage des fonctions}
\subsection{Full clients}
Ce genre de clients implémente la totalité du protocole Bitcoin, et garde en mémoire une copie de la totalité de la \textit{blockchain}. Leurs fonctionnalités peuvent se diviser en deux parties :
\begin{itemize}
	\item \textit{publique}\begin{itemize}
		\item Découvrir d'autres n\oe{}uds et communiquer avec eux
		\item envoyer et recevoir des transactions et des blocs
		\item enregistrer tous les blocs valides
		\item vérifier toutes les transactions reçues et \textit{broadcaster} toutes celles qui sont valides
	\end{itemize}
	\item pour l'utilisateur \begin{itemize}
		\item stocker son historique de transactions et les clefs privées pour le "portefeuille"
		\item offrir une interface (GUI ou ligne de commande) pour afficher les avoirs et l'historique des transactions, et générer de nouvelles transactions
	\end{itemize}
\end{itemize}
Ces clients renforcent la solidité du réseau et le rendent moins vulnérable aux attaques, mais sont coûteux en termes de mémoire, d'opérations (ils vérifient la validité de transactions qui ne concernent pas l'utilisateur) et de frais liés au réseau (ils reçoivent et émettent des transactions et des blocs en permanence).
\subsection{Headers-only clients}
Pour les appareils limités en mémoire, ou selon la volonté de l'utilisateur, un deuxième type de client existe, qui ne garde pas en mémoire toute la \textit{blockchain} mais uniquement les \textit{headers} des blocs (ce qui en mai 2012 représentait 14 Mo, à comparer avec les 2 Go de la totalité de la chaîne). Ils ne téléchargent la totalité d'un bloc que s'ils attendent une transaction, ou s'ils cherchent dans l'ensemble de la chaîne des transactions liées à des clefs qu'ils détiennent. Pour vérifier la validité d'une transaction les concernant, les n\oe{}uds utilisant ce client allégé se reposent sur la procédure \textit{Simplified Payment Verification}, décrite dès le papier fondateur. Dans la suite, nous décrivons le modèle utilisé par \textit{bitcoinj}.\\\\
Cette procédure simplifiée repose sur les n\oe{}uds mettant en \oe{}uvre la totalité du protocole (i.e. ayant en mémoire la totalité de la chaîne). Si le client bitcoinj se connecte à l'un d'entre eux, il ne sera informé d'une transaction que si celle-ci est jugée valide par ce n\oe{}ud. Une fois cette transaction incorporée dans un nouveau bloc (ce que le client bitcoinj peut vérifier s'il récupère ce bloc et contrôle sa validité), la profondeur de cette transaction dans la chaîne passe à 1, et le client bitcoinj ne récupère plus que les \textit{headers} des blocs suivants (qui à chaque fois contiennent une référence au bloc précédent), augmentant à chaque fois la profondeur de la transaction qui l'intéresse de 1. Il considère la transaction comme sûre une fois qu'elle est à une profondeur suffisante dans la chaîne (la valeur typiquement retenue étant de 6), c'est à dire une fois qu'il estime suffisamment peu probable que cette branche de la chaîne ne soit pas la branche finalement retenue.\\\\
On voit que tout repose sur la confiance que le client léger accorde au n\oe{}ud auquel il se connecte : la seule raison que l'on a de considérer une transaction comme légitime (i.e. celui qui paie est bien le propriétaire de ces bitcoins) - avant même les considérations de profondeur - est le fait qu'elle a été relayée, ce que n'aurait pas fait un n\oe{}ud complet honnête si la transaction n'était pas légitime. Pour s'assurer d'être connecté à des n\oe{}uds honnêtes, le client bitcoinj se connecte à des n\oe{}uds choisis aléatoirement\footnote{Il se connecte à un serveur DNS qui lui fournit une souche aléatoire qui varie tous les jours}, ce qui rend difficile pour un attaquant de contrôler la connectivité du client léger pour essayer de l'induire en erreur. Une fois que la transaction a été relayée par une fraction importante de nos pairs, on peut être assez sûr qu'elle se propage bien à travers tout le réseau et donc qu'elle est très probablement valide. \\\\
L'attaque principale liée à cette question de confiance (appelée \textit{Sybil attack}) a lieu si l'attaquant a la possibilité de contrôler entièrement notre connexion à Internet, et ainsi de nous présenter un faux réseau dans lequel tous les n\oe{}uds acceptent cette transaction pour nous faire croire qu'elle est valide, puis d'ajouter des blocs pour finir par nous faire croire qu'elle est définitive. Pour contrecarrer cela, il est envisagé de mettre en place des clients qui mesurent la vitesse à laquelle de nouveaux blocs sont minés : en effet, dans le cas où l'attaquant n'est pas dans une configuration de puissance de type 51\%, cette vitesse décroîtrait brutalement avec l'usurpation, et le client pourrait ainsi signaler à l'utilisateur que la situation est douteuse.
\subsection{Signing-only clients}
\begin{figure}[h]
	\includegraphics[width=10cm]{en-wallets-signing-only}
\end{figure}
Les \textit{signing-only clients} vont encore une étape plus loin dans la délégation de compétence : le client ne télécharge pas la blockchain, ni même les headers. Il se base sur un autre client pour lui fournir les transactions qui concernent l'utilisateur et la situation financière de ce dernier, et ne garde en propre que la partie signature. Ce cas de figure a deux fonctions principales :\begin{itemize}
	\item sécuriser les clefs : un utilisateur peut être prêt à installer sur un de ses appareils un client Bitcoin complet, mais estimer que conserver ses clefs sur un appareil connecté à l'extérieur n'est pas raisonnable ; il découpe ainsi son client en deux parties, l'une participant au réseau et lui indiquant notamment les transactions qu'il reçoit, vérifiant leur validité et leur inclusion dans la chaîne,... et l'autre, sur un appareil distinct et isolé de l'extérieur, contenant ses clefs privées et étant donc la seule à pouvoir dépenser ses bitcoins. Il y a plusieurs possibilités pour implémenter cette séparation :\begin{itemize}
		\item Faire des transferts avec par exemple une clef USB entre les deux équipements, ce qui est contraignant
		\item Acheter une implémentation physique de cette partie signature, par exemple un appareil doté d'une connexion USB, sur lequel peut se trouver un dispositif de type code PIN,... pour plus de sécurité.
	\end{itemize}
	\item confier à un serveur le soin de suivre les transactions nous concernant et de nous indiquer nos avoirs. Cela suppose un certain niveau de confiance dans le serveur, qui peut nous induire en erreur en nous indiquant de fausses transactions que l'on aurait reçues, nous trompant ainsi sur la quantité de bitcoins que nous détenons. Ce genre d'attaque est d'une importance limitée, puisque le serveur ne peut en aucun cas dépenser lui-même les bitcoins que nous possédons (nous faire signer des transactions contre notre volonté). Il est de plus possible d'éviter cette attaque en nous connectant à plusieurs serveurs indépendants, ou même à notre propre serveur\footnote{Il existe des logiciels open source permettant de réaliser ce genre de serveurs. L'intérêt de cette démarche est de pouvoir utiliser un client complet sur un appareil contraint (type mobile), en utilisant un serveur externe pour réaliser la partie la plus exigeante.}. 
\end{itemize}
Le client peut être une application PC, mobile ou web ; dans le cas d'une application Web, la signature est faite dans le browser, et les clefs ne sont donc pas envoyées.

\subsection{Thin clients}
Mt.Gox,...
Le client ne détient pas ses clefs et ne signe pas lui-même ses transactions, il demande à un serveur distant de faire cela pour lui. En ce sens, c'est exactement la même chose qu'une banque et toute la motivation de base du Bitcoin - se passer de tiers-partie - disparaît. Il convient aussi de souligner que ces acteurs sont loin du niveau de garantie offert par les banques.

\section{Sécurité des clefs}
\subsection{Appareils connectés à l'extérieur}
\subsection{Perte/casse/vol}
\subsection{Brain wallets}
\subsection{Une solution :m-of-n signature}
Concept beaucoup plus général et intéressant (arbitres,...), mais qui peut être mis à profit ici.
\bibliography{biblio}{}
\bibliographystyle{plain}

\end{document}